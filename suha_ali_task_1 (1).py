# -*- coding: utf-8 -*-
"""Suha Ali- Task-1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M21-hggSG9uv8ID45n6CuLPb0MRk1vwI
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
import json
import tempfile
import os

"""# 1. DOCUMENT EDITOR"""

class Document(ABC):
    def __init__(self, content: str):
        self.content = content

    @abstractmethod
    def display(self) -> str:
        pass

    @abstractmethod
    def save(self, filename: str) -> None:
        pass


class PDFDocument(Document):
    def display(self) -> str:
        return f"[PDF] {self.content}"

    def save(self, filename: str) -> None:
        with open(filename, 'w') as f:
            f.write(f"%PDF-1.4\n{self.content}")


class WordDocument(Document):
    def display(self) -> str:
        return f"[DOCX] {self.content}"

    def save(self, filename: str) -> None:
        with open(filename, 'w') as f:
            f.write(f"DOCX:{self.content}")


class HTMLDocument(Document):
    def display(self) -> str:
        return f"<html><body>{self.content}</body></html>"

    def save(self, filename: str) -> None:
        with open(filename, 'w') as f:
            f.write(self.display())


class DocumentFactory:
    _formats: Dict[str, type] = {
        'pdf': PDFDocument,
        'word': WordDocument,
        'html': HTMLDocument
    }

    @classmethod
    def register_format(cls, name: str, doc_class: type):
        cls._formats[name.lower()] = doc_class

    @classmethod
    def create_document(cls, fmt: str, content: str) -> Document:
        fmt = fmt.lower()
        if fmt not in cls._formats:
            raise ValueError(f"Unsupported format: {fmt}")
        return cls._formats[fmt](content)

"""# 2. CAR BUILDER"""

class Car:
    def __init__(self):
        self.engine: Optional[str] = None
        self.transmission: Optional[str] = None
        self.interior: List[str] = []
        self.exterior: List[str] = []
        self.safety: List[str] = []

    def is_valid(self) -> bool:
        return self.engine is not None and self.transmission is not None

    def __str__(self) -> str:
        return (
            f"Car(engine={self.engine}, transmission={self.transmission}, "
            f"interior={self.interior}, exterior={self.exterior}, safety={self.safety})"
        )

    def to_dict(self) -> dict:
        return {
            "engine": self.engine,
            "transmission": self.transmission,
            "interior": self.interior,
            "exterior": self.exterior,
            "safety": self.safety
        }


class CarBuilder:
    def __init__(self):
        self.reset()

    def reset(self):
        self._car = Car()

    def set_engine(self, engine: str):
        self._car.engine = engine
        return self

    def set_transmission(self, transmission: str):
        if transmission not in ("manual", "automatic"):
            raise ValueError("Transmission must be 'manual' or 'automatic'")
        self._car.transmission = transmission
        return self

    def add_interior(self, feature: str):
        self._car.interior.append(feature)
        return self

    def add_exterior(self, option: str):
        self._car.exterior.append(option)
        return self

    def add_safety(self, feature: str):
        self._car.safety.append(feature)
        return self

    def build(self) -> Car:
        if not self._car.is_valid():
            raise ValueError("Car must have engine and transmission")
        car = self._car
        self.reset()
        return car

"""# 3. COMBINED APP"""

class CarDocumentGenerator:
    @staticmethod
    def generate_content(car: Car, fmt: str) -> str:
        data = car.to_dict()
        if fmt == 'html':
            content = "<h1>Car Configuration Report</h1>\n<ul>\n"
            for key, value in data.items():
                if isinstance(value, list):
                    value_str = ", ".join(value) if value else "None"
                else:
                    value_str = value or "Not set"
                content += f"<li><strong>{key.title()}:</strong> {value_str}</li>\n"
            content += "</ul>"
            return content
        elif fmt in ('pdf', 'word'):
            lines = ["Car Configuration Report"]
            for key, value in data.items():
                if isinstance(value, list):
                    value_str = ", ".join(value) if value else "None"
                else:
                    value_str = value or "Not set"
                lines.append(f"{key.title()}: {value_str}")
            return "\n".join(lines)
        else:
            raise ValueError(f"Unsupported format for generation: {fmt}")

    @classmethod
    def create_car_document(cls, car: Car, fmt: str, filename: str = None) -> Document:
        content = cls.generate_content(car, fmt)
        doc = DocumentFactory.create_document(fmt, content)
        if filename:
            doc.save(filename)
        return doc

"""# 4. DEMO USAGE"""

if __name__ == "__main__":
    # Build a car
    builder = CarBuilder()
    my_car = (builder
              .set_engine("V6")
              .set_transmission("automatic")
              .add_interior("Leather Seats")
              .add_interior("GPS Navigation")
              .add_exterior("Midnight Blue")
              .add_exterior("Alloy Rims")
              .add_safety("ABS")
              .add_safety("Rear Camera")
              .build())

    print("Car built:", my_car)

    # Generate and save an HTML document
    with tempfile.NamedTemporaryFile(suffix='.html', delete=False, mode='w') as tmp:
        doc = CarDocumentGenerator.create_car_document(my_car, 'html', tmp.name)
        print("\nGenerated document preview:")
        print(doc.display()[:200] + "...")

        print(f"\n Saved HTML report to: {tmp.name}")

    # Clean up (optional)
    # os.unlink(tmp.name)